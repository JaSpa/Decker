#######################################
#
#  Lilt / Lilac / Decker
#  DOM integration test suite
#
#######################################

on matrix_show i do
	cw:1+9<max max i
	f:"%%%ii" format cw
	b:"+%s+" format (cw*count first i) take "-"
	print[b]
	print[("\n","|%s|","",f) format i]
	print[b]
end
on image_format i do
	i:image_matrix[i]
	cw:1+9<max max i
	f:"%%%ii" format cw
	print["(%s)" format (",\n ","(list %s)",",",f) format i]
end
on image_matrix i do
	s:i.size
	r:each y in range s[1]
		each x in range s[0] i[x,y] end
	end
	if 0~count r list r else r end
end

#######################################
#
#  Test Framework
#
#######################################

on assert_file text want got do
	s:shell["cmp -s %s %s" format want,got] # exit code { 0:matched, 1:differed, 2:error }
	if s.exit
		print["test failed: %s" text]
		print["binary file '%s' does not match '%s'" format got,want]
		exit[1]
	end
	shell["rm %s" format got]
end
on assert_base text want got disp do
	#print["%s..." text]
	if !want~got
		print["test failed: %s" text]
		print["expected:"] disp[want]
		print["got:"]      disp[got]
		exit[1]
	end
end
on assert text want got do
	assert_base[text want got show]
end
on assert_image text want got do
	assert_base[text want image_matrix[got] matrix_show]
end

#######################################
#
#  Arrays
#
#######################################

a:array[4 "i16l"]
assert["array from scratch" "array" (typeof a)]
assert["array cast" "i16l" a.cast]
assert["array size" 4      a.size]
a[3]:99
assert["array scalar r/w" 99 a[3]]
a[1,3]:333
assert["array scalar spread" (0,333,333,333) a[0,4]]
a[0,4]:11,22,33,44,55
assert["array vector r/w" (11,22,33,44) a[0,4]]
assert["array left OOB"   0 a[-1]]

assert["array encode" "%%DAT5CwAWACEALAA=" a.encoded]
dec:array["%%DAT5CwAWACEALAA="]
assert["array decode" ("i16l",list 11,22,33,44) dec.cast,list dec[0,4]]

s:a.slice[1,2]
assert["array slice read" ("i16l",2,0,33) (s.cast,s.size,s.here,s[1])]
s[0]:77
assert["array slice writethru" 77 a[1]]
s[2]:88
assert["array slice oob write" 44 a[3]]

c:a.copy[1,5]
assert["array copy read" ("i16l",5,0,list 77,33,44,0) (c.cast,c.size,c.here,list c[0,4])]
c[0]:103
assert["array copy no writethru" 77 a[1]]

a[0]:"ABCDEFG"
assert["array char write" (65,77) a[0,2]]
a[0,4]:"ABCDEFG"
assert["array string write" (65,66,67,68) a[0,4]]
a.cast:"i8"
assert["array splayed chars" (65,0,66,0) a[0,4]]
a.cast:"char"
a[0,4]:"ABCDEFG"
assert["array string read" "ABCD" a[0,4]]
a.cast:"i8"
a[0,4]:(0,10,65,13)
a.cast:"char"
assert["array read denormal chars" "?\nA" a[0,4]]
a.cast:"u8"
a[0,4]:(226,128,156,65)
a.cast:"char"
assert["array read utf-surrogate" "\"A" a[0,4]]

a:array[2 "i16l"]
a[0,2]:"AB"
a.size:5
assert["array resize bigger" (65,66,0,0,0) a[0,a.size]]
a.size:1
assert["array resize smaller" (list 65) a[0,a.size]]
b:a.slice[0,2] b.size:5
assert["array slices can't resize" (1,2) (a.size,b.size)]

a:array[4 "i32b"] # need capacity for the biggest-size cast!
on limits cast nums do
	a.cast:cast
	o:0,count nums
	a[o]:nums
	assert[("array %s r/w limits" format cast) nums a[o]]
end
limits["u8"               0,1,255       ]
limits["i8"          -128,0,1,127       ]
limits["u16b"             0,1,65535     ]
limits["u16l"             0,1,65535     ]
limits["i16b"      -32768,0,1,32767     ]
limits["i16l"      -32768,0,1,32767     ]
limits["u32b"             0,1,4294967295]
limits["u32l"             0,1,4294967295]
limits["i32b" -2147483648,0,1,2147483647]
limits["i32l" -2147483648,0,1,2147483647]

bin:read["tests/dom/a.gif" "array"]
assert["read array from file" (86,"array") (bin.size,typeof bin)]
write["temp.gif" bin]
assert_file["write file from array" "tests/dom/a.gif" "temp.gif"]

gif.magic      :"char",6  # "GIF89a" magic number.
gif.size       :"u16l",2  # (width,height) in pixels.
gif.gct.present:1         # flag: is there a global colortable?
gif.gct.res    :3         # color resolution (almost always 7; 8-bits per channel).
gif.gct.sorted :1         # flag: are the colors sorted by importance? (almost always zero).
gif.gct.size   :3         # number of entries in the global colortable.
gif.background :"u8"      # index of the background color.
gif.aspect     :"u8"      # pixel aspect ratio (almost always zero).

rgif.magic      :"GIF89a"
rgif.size       :8,9
rgif.gct.present:1
rgif.gct.res    :7
rgif.gct.sorted :0
rgif.gct.size   :0
rgif.background :1
rgif.aspect     :0

assert["array read struct" rgif bin.struct[gif]]
cpy:array[0]
cpy.struct[gif rgif]
assert["array write struct" bin.slice[0,13].encoded cpy.encoded]
cpy.struct["u8",6 (11,22,33,44,55,66)]
assert["array write here"   19 cpy.here]
assert["array write field"  (11,22,33,44,55,66) cpy[13,6]]
cpy.here:0
assert["array read field"   "GIF89a" cpy.struct["char",6]]

blob:array["%%DAT08J+SqQ=="]
a:array[0 "u16l"]
a.cat["TEXT"]
a.cat[345,9000]
a.cat[blob]
b:array[0 "u16l"].cat["TEXT"].cat[345,9000].cat[blob]
c:array[0 "u16l"].cat["TEXT" 345,9000 blob]
assert["array cat"          "%%DAT3VEVYVFkBKCPwn5Kp" a.encoded]
assert["array cat, chained" "%%DAT3VEVYVFkBKCPwn5Kp" b.encoded]
assert["array cat, multi"   "%%DAT3VEVYVFkBKCPwn5Kp" c.encoded]
assert["array cat payload"  "%%DAT38J+SqQ=="         c.slice[4].encoded]

#######################################
#
#  Images
#
#######################################

assert["new image from nothing" "image" (typeof image[])]
assert_image["new image with size"
	((list 0,0,0),
	 (list 0,0,0),
	 (list 0,0,0),
	 (list 0,0,0))
	image[3,4]
]

smol:image[3,4]
smol[1,1]:2
smol[2,3]:6
assert_image["write to image"
	((list 0,0,0),
	 (list 0,2,0),
	 (list 0,0,0),
	 (list 0,0,6))
	smol
]

smol.size:5,6
assert_image["resize image larger"
	((list 0,0,0,0,0),
	 (list 0,2,0,0,0),
	 (list 0,0,0,0,0),
	 (list 0,0,6,0,0),
	 (list 0,0,0,0,0),
	 (list 0,0,0,0,0))
	smol
]

smol.size:2,2
assert_image["resize image smaller"
	((list 0,0),
	 (list 0,2))
	smol
]

img:image[4,3]
img[0,1]:1
img[0,2]:2
img[1,2]:3
img[2,0]:4
img.map[1,0,0,0,3]
assert_image["image map"
	((list 1,1,3,1),
	 (list 0,1,1,1),
	 (list 0,0,1,1))
	img
]
img.map[5000 dict 23] # bogus input indices, no fill
assert_image["image dict map"
	((list 6,6,5,6),
	 (list 0,6,6,6),
	 (list 0,0,6,6))
	img.copy[].map[(3,1) dict 5,6]
]
assert_image["image dict map and fill"
	((list 8,8,9,8),
	 (list 9,8,8,8),
	 (list 9,9,8,8))
	img.copy[].map[1 dict 8 9]
]
img.transform["horiz"]
assert_image["image mirror horiz"
	((list 1,3,1,1),
	 (list 1,1,1,0),
	 (list 1,1,0,0))
	img
]
img.transform["vert"]
assert_image["image mirror vert"
	((list 1,1,0,0),
	 (list 1,1,1,0),
	 (list 1,3,1,1))
	img
]
img.transform["flip"]
assert_image["image transpose"
	((list 1,1,1),
	 (list 1,1,3),
	 (list 0,1,1),
	 (list 0,0,1))
	img
]
img.transform["left"]
assert_image["image rotate left"
	((list 1,3,1,1),
	 (list 1,1,1,0),
	 (list 1,1,0,0))
	img
]
img.transform["right"]
assert_image["image rotate right"
	((list 1,1,1),
	 (list 1,1,3),
	 (list 0,1,1),
	 (list 0,0,1))
	img
]

assert["image encode" "%%IMG2AAMABAEFAwEAAQECAAIBAQ==" img.encoded]
assert_image["image decode"
	((list 1,1,1),
	 (list 1,1,3),
	 (list 0,1,1),
	 (list 0,0,1))
	image["%%IMG2AAMABAEFAwEAAQECAAIBAQ=="]
]

assert_image["image copy"
	((list 1,1,0),
	 (list 1,3,0))
	img.copy[1,0 3,2]
]
dst:image[5,6]
ret:dst.paste[img 2,1]
assert_image["image paste"
	((list 0,0,0,0,0),
	 (list 0,0,1,1,1),
	 (list 0,0,1,1,3),
	 (list 0,0,0,1,1),
	 (list 0,0,0,0,1),
	 (list 0,0,0,0,0))
	dst
]
assert["image paste returns self" dst ret]
dst.paste[img 3,1,-3,4]
assert_image["image paste, negative scale (no effect)"
	((list 0,0,0,0,0),
	 (list 0,0,1,1,1),
	 (list 0,0,1,1,3),
	 (list 0,0,0,1,1),
	 (list 0,0,0,0,1),
	 (list 0,0,0,0,0))
	dst
]
self:image[2,6]
self[0,0]:11
self[0,1]:22
self[1,0]:44
self[1,1]:33
self.paste[self 0,2]
assert_image["image paste onto itself"
	((list 11,44),
	 (list 22,33),
	 (list 11,44),
	 (list 22,33),
	 (list  0, 0),
	 (list  0, 0))
	self
]
assert["image histogram" ((0,11,22,33,44) dict (4,2,2,2,2)) self.hist]

mi:image["%%IMG0AA4ADQAAA8AH4B/gP/A/8D/4P/gf+B/4D/AH4AAA"].merge[image["%%IMG1AAIAAyYkJCYmJA=="] image["%%IMG0AAYABviIqLiA/A=="]]
assert["image merge" "%%IMG1AA4ADSYkJiQmJCYkJiQmJCYkJCYkJiQmAQAAACQmJCYmJCYkJgABAAEAASQmJCYkJgEBAAEAAQEBJCYkJCYAAAAAAQAAAAAAJCYmJAEBAQEBAQEBAQEmJCYkAQEBAAEBAQEBAAEkJCYAAAEAAQAAAAEAASYmJCYAAQABAAEAAQABJCYkJgEBAAEAAQEBAAEkJCYkJgAAAQAAAAAAJCYmJCYkJgEBAQEBASQmJCYkJiQmJCYkJiQmJCYk" mi.encoded]

horiz:image["%%IMG2AAgACAAIAQgCCAMIBAgFCAYIBwg="]
vert :image["%%IMG1AAgACAABAgMEBQYHAAECAwQFBgcAAQIDBAUGBwABAgMEBQYHAAECAwQFBgcAAQIDBAUGBwABAgMEBQYHAAECAwQFBgc="]
assert["image + merge" "%%IMG1AAgACAABAgMEBQYHAQIDBAUGBwgCAwQFBgcICQMEBQYHCAkKBAUGBwgJCgsFBgcICQoLDAYHCAkKCwwNBwgJCgsMDQ4=" horiz.copy[].merge["+" vert].encoded]
assert["image - merge" "%%IMG1AAgACAD//v38+/r5AQD//v38+/oCAQD//v38+wMCAQD//v38BAMCAQD//v0FBAMCAQD//gYFBAMCAQD/BwYFBAMCAQA=" horiz.copy[].merge["-" vert].encoded]
assert["image & merge" "%%IMG1AAgACAAAAAAAAAAAAAEBAQEBAQEAAQICAgICAgABAgMDAwMDAAECAwQEBAQAAQIDBAUFBQABAgMEBQYGAAECAwQFBgc=" horiz.copy[].merge["&" vert].encoded]
assert["image | merge" "%%IMG1AAgACAABAgMEBQYHAQECAwQFBgcCAgIDBAUGBwMDAwMEBQYHBAQEBAQFBgcFBQUFBQUGBwYGBgYGBgYHBwcHBwcHBwc=" horiz.copy[].merge["|" vert].encoded]
assert["image = merge" "%%IMG0AAgACIBAIBAIBAIB"                                                                             horiz.copy[].merge["=" vert].encoded]
assert["image > merge" "%%IMG0AAgACACAwODw+Pz+"                                                                             horiz.copy[].merge[">" vert].encoded]
assert["image < merge" "%%IMG0AAgACH8/Hw8HAwEA"                                                                             horiz.copy[].merge["<" vert].encoded]
assert["image op merge with empty image" horiz.encoded horiz.copy[].merge["+" image[0,0]].encoded]

a:image[2,1] a[0,0]:100 a[1,0]:1
b:image[2,1] b[0,0]:200 b[1,0]:5
assert["image merge overflow"  (list  44,  6) image_matrix[a.copy[].merge["+" b]]]
assert["image merge underflow" (list 156,252) image_matrix[a.copy[].merge["-" b]]]

assert_image["read nonexistent gif"
	list ()
	read["tests/dom/fake.gif"]
]
assert_image["read malformed/invalid gif"
	list ()
	read["tests/dom/a.png"]
]
assert_image["read gif with transparency"
	((list 0,0,0,0,0,0,0,0),
	 (list 0,0,1,1,1,1,0,0),
	 (list 0,1,0,0,0,1,1,0),
	 (list 0,0,1,1,1,1,1,0),
	 (list 0,1,1,0,0,1,1,0),
	 (list 0,1,1,0,0,1,1,0),
	 (list 0,1,1,0,0,1,1,0),
	 (list 0,0,1,1,1,1,1,0),
	 (list 0,0,0,0,0,0,0,0))
	read["tests/dom/a.gif"]
]
assert_image["read gif with opaque background"
	((list 32,32,32,32,32,32,32,32),
	 (list 32,32, 1, 1, 1, 1,32,32),
	 (list 32, 1,32,32,32, 1, 1,32),
	 (list 32,32, 1, 1, 1, 1, 1,32),
	 (list 32, 1, 1,32,32, 1, 1,32),
	 (list 32, 1, 1,32,32, 1, 1,32),
	 (list 32, 1, 1,32,32, 1, 1,32),
	 (list 32,32, 1, 1, 1, 1, 1,32),
	 (list 32,32,32,32,32,32,32,32))
	read["tests/dom/a-opaque.gif"]
]

assert["read invalid gif frames" (("frames","delays") dict (list ()),(list())) read["bogus.gif" "frames"]]

ae:"%%IMG0AAgACwA8Rj5mZmY+AAAA"
be:"%%IMG0AAgACwBgYHxmZmZmZnwA"
each s in ("opt","blessed")
	f:read[("tests/dom/ab-%s.gif" format s) "frames"]
	assert[("read animated %s.gif delays" format s) (3,3)   f.delays]
	assert[("read animated %s.gif frames" format s) (ae,be) f.frames..encoded]
end

con:("%%IMG2ACYAJgARAQQAIQEGAB8BAiEEAQIAHQECIQYBAgAbAQIhCAECABkBAiEKAQIAFwECIQwBAgAVAQIhBQEEIQUBAgATAQIhBQEGIQUBAgARAQIhBgEGIQYBAgAPAQIhBwEGIQcBAgANAQIhCAEGIQgBAgALAQIhAgEHIQEBBCEKAQIACQECIQMBASEDAQQhDwECAAcBAiEFAQEhAQEGIQ8BAgAFAQIhBgEGIQEBASEQAQIAAwECIQcBBSECAQEhEQECAAEBAiEHAQYhAgEBIRIBBCEHAQUhAQEBIQEBASESAQQhBwEFIQIBAiESAQQhBwEGIQIBASESAQIAAQECIQYBByECAQEhEAECAAMBAiEFAQMhAQEEIQIBASEOAQIABQECIQQBAyECAQMhAwEBIQwBAgAHAQIhAwEDIQIBAyEEAQMhCAECAAkBAiECAQMhAgEDIQQBBCEGAQIACwECIQEBAyECAQIhBAEGIQQBAgANAQIhAQECIQIBAyECAQghAgECAA8BAiEBAQEhAgEDIQIBCCEBAQIAEQECIRABAgATAQIhDgECABUBAiEMAQIAFwECIQoBAgAZAQIhCAECABsBAiEGAQIAHQECIQQBAgAfAQYAIQEEABE=","%%IMG2ACYAJgARAQQAIQEGAB8BAiEEAQIAHQECIQYBAgAbAQIhCAECABkBAiEKAQIAFwECIQwBAgAVAQIhBQEEIQUBAgATAQIhBQEGIQUBAgARAQIhBgEGIQYBAgAPAQIhBwEGIQcBAgANAQIhCAEGIQgBAgALAQIhAQEIIQEBBCEKAQIACQECIQIBASEEAQQhDwECAAcBAiEEAQEhAgEGIQ8BAgAFAQIhBgEGIQEBASEQAQIAAwECIQcBBSECAQEhEQECAAEBAiEHAQUhAQEBIQEBASESAQQhBwEFIQIBAiESAQQhBwEFIQQBASERAQQhBwEGIQQBASEQAQIAAQECIQYBByEEAQEhDgECAAMBAiEFAQMhAQEEIQQBBCEJAQIABQECIQQBAyECAQMhBAEFIQcBAgAHAQIhAwEDIQIBAyEEAQUhBgECAAkBAiECAQMhAgEDIQQBBSEFAQIACwECIQEBAyECAQIhBAEGIQQBAgANAQIhAQECIQIBAyECAQghAgECAA8BAiEBAQEhAgEDIQIBCCEBAQIAEQECIRABAgATAQIhDgECABUBAiEMAQIAFwECIQoBAgAZAQIhCAECABsBAiEGAQIAHQECIQQBAgAfAQYAIQEEABE=","%%IMG2ACYAJgARAQQAIQEGAB8BAiEEAQIAHQECIQYBAgAbAQIhCAECABkBAiEKAQIAFwECIQwBAgAVAQIhBQEEIQUBAgATAQIhBQEGIQUBAgARAQIhBgEGIQYBAgAPAQIhBwEGIQcBAgANAQIhCAEGIQgBAgALAQIhAQEIIQEBBCEKAQIACQECIQIBASEEAQQhDwECAAcBAiEDAQEhAwEGIQ8BAgAFAQIhBAEBIQEBBiEBAQEhEAECAAMBAiEFAQchAgEBIREBAgABAQIhBwEFIQMBASESAQQhBwEHIQEBASEFAQIhCwEEIQcBBSECAQMhAwEEIQoBBCEHAQYhBAEIIQkBAgABAQIhBgEHIQUBBiEIAQIAAwECIQUBAyEBAQQhBAEGIQcBAgAFAQIhBAEDIQIBAyEHAQMhBgECAAcBAiEDAQMhAgEDIQUBAiEIAQIACQECIQIBAyECAQMhBAEEIQYBAgALAQIhAQEDIQIBAiEEAQYhBAECAA0BAiEBAQIhAgEDIQIBCCECAQIADwECIQEBASECAQMhAgEIIQEBAgARAQIhEAECABMBAiEOAQIAFQECIQwBAgAXAQIhCgECABkBAiEIAQIAGwECIQYBAgAdAQIhBAECAB8BBgAhAQQAEQ==","%%IMG2ACYAJgARAQQAIQEGAB8BAiEEAQIAHQECIQYBAgAbAQIhCAECABkBAiEKAQIAFwECIQwBAgAVAQIhBQEEIQUBAgATAQIhBQEGIQUBAgARAQIhBgEGIQYBAgAPAQIhBwEGIQQBAiEBAQIADQECIQgBBiECAQEhAQECIQIBAgALAQIhAQEIIQEBBCEKAQIACQECIQIBASEEAQQhCAEBIQYBAgAHAQIhAwEBIQMBBiEHAQEhAQEBIQUBAgAFAQIhBAEBIQEBBiEBAQEhBQEBIQMBASEGAQIAAwECIQUBASEBAQUhAgEBIQUBASEBAQEhCQECAAEBAiEGAQYhAwEBIRIBBCEGARUhBwEEIQcBBSEDAQEhBQEFIQgBBCEHAQYhCAEEIQkBAgABAQIhBgEHIRMBAgADAQIhBQEDIQEBBCERAQIABQECIQQBAyECAQMhEAECAAcBAiEDAQMhAgEDIQUBAiEIAQIACQECIQIBAyECAQMhBAEEIQYBAgALAQIhAQEDIQIBAiEEAQYhBAECAA0BAiEBAQIhAgEDIQIBCCECAQIADwECIQEBASECAQMhAgEIIQEBAgARAQIhEAECABMBAiEOAQIAFQECIQwBAgAXAQIhCgECABkBAiEIAQIAGwECIQYBAgAdAQIhBAECAB8BBgAhAQQAEQ==")
assert["read color animated gif" con (read["tests/dom/construction.gif" "frames"].frames..encoded)]

if !sys.platform~"web"
	frame_a:read["tests/dom/a.gif"]
	write["temp.gif" frame_a]
	assert_file["round-trip transparent gif" "tests/dom/a-blessed.gif" "temp.gif"]

	frame_b:read["tests/dom/b.gif"]
	write["temp.gif" (frame_a,frame_b)]
	assert_file["write animated gif with different frame sizes" "tests/dom/ab-blessed.gif" "temp.gif"]

	parts:()
	parts.frames:frame_a,frame_b,frame_a
	parts.delays:7,5,0
	write["temp.gif" parts]
	f:read["temp.gif" "frames"]
	assert["round-trip animated gif frame delays" (7,5,1) f.delays]

	parts.delays:9
	write["temp.gif" parts]
	f:read["temp.gif" "frames"]
	assert["spread gif frame delay" (9,9,9) f.delays]

	parts.frames:9
	assert["don't write gif if given bogus frames." 0 write["temp.gif" parts]]
	parts.frames:frame_a
	assert["spread gif frame" 1 write["temp.gif" parts]]

	frame_a.size:0,0
	assert["cannot write out a gif of dimension 0 on either axis." 0 write["temp.gif" frame_a]]
end

rot:"%%IMG2ACgAIgD/AFsBAQAlAQQAIgEGACABBwAeAQoAHgEKAB8BCQAgAQcAIAEIAB8BCQAeAQQAAQEEAB4BBAADAQMAHQEEAAUBAQAdAQQAJAEDACYBAQD/AKo="
assert["rotate image negative"
	"%%IMG2ACgAIgD/APEBAwAkAQQABwEBABsBBQACAQEAAQEFABkBBgABAQgAGQEMAAEBAgAYAQsAHAEKAB0BDAAdAQsAIAEIAP8A8w=="
	image[rot].rotate[pi*-.8].encoded
]
assert["rotate image positive"
	"%%IMG2ACgAIgD/AJ0BAgAlAQcAIgEJAB8BCwAeAQsAHQEKAB8BCAAgAQcAIgEHACEBAwABAQQAIAECAAMBBAAlAQQAJQEEACUBBAAlAQIA/wB3"
	image[rot].rotate[pi*3.5].encoded
]
assert["rotate image empty" image[0,0].encoded image[0,0].rotate[pi].encoded]

a:"%%IMG0AAsACQAACAAIABQAEgA/ACCAccAAAA=="
assert["translate image clamped" "%%IMG0AAsACQAAAAACAAIABQAEgA/ACCAcYA==" image[a].translate[2,1   ].encoded]
assert["translate image floored" "%%IMG0AAsACQAAAAACAAIABQAEgA/ACCAcYA==" image[a].translate[2.3,1.2].encoded]
assert["translate image wrapped" "%%IMG0AAsACfggBCCOYAAAAABAAEAAoACQAA==" image[a].translate[-3,4 1].encoded]

b:"%%IMG0AAcACAA4fGx8bGwA"
assert["scale image up uniform"    "%%IMG0AA4AEAAAAAAPwA/AP/A/8DzwPPA/8D/wPPA88DzwPPAAAAAA"                         image[b].scale[ 2  ].encoded]
assert["scale image up nonuniform" "%%IMG0AA4AGAAAAAAAAA/AD8APwD/wP/A/8DzwPPA88D/wP/A/8DzwPPA88DzwPPA88AAAAAAAAA==" image[b].scale[ 2,3].encoded]
assert["scale image down"          "%%IMG0AAQACAAgcFBwUFAA"                                                         image[b].scale[.7,1].encoded]
assert["scale image negative"      "%%IMG2AAAAAA=="                                                                 image[b].scale[-3,4].encoded]
assert["scale image none"          "%%IMG2AAAAAA=="                                                                 image[b].scale[    ].encoded]

#######################################
#
#  General File IO
#
#######################################

f:read["tests/dom/bom.txt"]
assert["read text files with a UTF-8 BOM" "Some ASCII contents after the bom!" f]
assert["correct string length given BOM" 34 (count f)]

r:"text with \"double\" and 'single' curly-quotes,\na tab: ,\nand a horrifying abomination:?\n"
f:read["tests/dom/quotes.txt"]
assert["read text files with illegal characters" r f]
d:readdeck["tests/dom/badchars.deck"]
assert["read deck with illegal characters in a script" r d.script]

d:readdeck["tests/dom/barenums.deck"]
assert["read deck with non-sequential numeric card names:keys" ("0","55","2") (keys d.cards)]
assert["read deck with non-sequential numeric card names:wids" "Fine" d.cards["55"].widgets.button1.text]

#######################################
#
#  Card
#
#######################################

deck:readdeck[]
card:deck.card

dattr:()
dattr.name:    "home"
dattr.script:  ""
dattr.size:    512,342
dattr.image:   "image"
dattr.widgets: "dict"
on cardattrs x do
	r:()
	r.name:    x.name
	r.script:  x.script
	r.size:    x.size
	r.image:   typeof x.image
	r.widgets: typeof x.widgets
end
assert["card default attributes and types" dattr cardattrs[card]]
assert["card default image size" (512,342) card.image.size]

w1:card.add["button" "thingy"]
w2:card.add["field" "zoot"]
assert["card add widgets" (("thingy","zoot")dict w1,w2) card.widgets]

r:card.remove[w1]
assert["card remove a widget" (().zoot:w2) card.widgets]
assert["card removed" 1 r]

w1.index:3
assert["removed widgets are inert" (().zoot:w2) card.widgets]
assert["removed widgets are inert" 0 w1.name]

r:card.remove[card]
assert["card remove bogus value" (().zoot:w2) card.widgets]
assert["card remove bogus value fail" r 0]

deck:readdeck[]
card:deck.card
card.name:"home"
assert["card rename identity" "home" card.name]
card.name:"Card Names can be anything"
assert["card rename fancy string" "Card Names can be anything" card.name]
card.name:""
assert["card rename empty" "Card Names can be anything" card.name]

#######################################
#
#  Button
#
#######################################

deck:readdeck[]
card:deck.card
b:card.add["button"]

# this one's a bit longer than most, since
# it probes even the common widget properties:
dattr:()
dattr.name:    "button1"
dattr.font:    deck.fonts.menu
dattr.script:  ""
dattr.locked:  0
dattr.animated:0
dattr.size:    60,20
dattr.pos:     0,0
dattr.show:    "solid"
dattr.text:    ""
dattr.value:   0
dattr.style:   "round"
dattr.shortcut:""
on buttonattrs x do
	r:()
	r.name:    x.name
	r.font:    x.font
	r.script:  x.script
	r.locked:  x.locked
	r.animated:x.animated
	r.size:    x.size
	r.pos:     x.pos
	r.show:    x.show
	r.text:    x.text
	r.value:   x.value
	r.style:   x.style
	r.shortcut:x.shortcut
end
assert["button default attributes and types" dattr buttonattrs[b]]

dattr.name:     b.name:     "bertram butan"
dattr.font:     b.font:     deck.fonts.menu
dattr.script:   b.script:   "2+3"
dattr.locked:   b.locked:   1
dattr.animated: b.animated: 1
dattr.size:     b.size:     32,48
dattr.pos:      b.pos:      12,34
dattr.show:     b.show:     "invert"
dattr.text:     b.text:     "Click Me!"
dattr.value:    b.value:    1
dattr.style:    b.style:    "check"
dattr.shortcut: b.shortcut: "x"
assert["button mutable attributes" dattr buttonattrs[b]]

dattr.name:"23"             b.name: 23
dattr.font:deck.fonts.body  b.font: "zoop"
dattr.script:"0"            b.script: 0
dattr.locked:1              b.locked: 99
dattr.animated:1            b.animated: 37
dattr.size:0,19             b.size: -12,19
dattr.pos:-99,0             b.pos:-99,"A"
dattr.show:"solid"          b.show:"frizzle"
dattr.text:""               b.text:()
dattr.value:1               b.value:"anything"
dattr.style:"round"         b.style:0
dattr.shortcut:"a"          b.shortcut:"Axe"
assert["button attribute sanitizing" dattr buttonattrs[b]]

b.pos:13.5,7.9
b.size:13.7,15.9999
assert["widget size and position are integers" (13,7,13,15) b.pos,b.size]

deck:readdeck[]
card:deck.card
b:card.add["button"]
b.name:"foof"
b.name:"foof"
assert["button identity renaming" "foof" b.name]

b.toggle[]
assert["button toggle off" "none" b.show]
s:b.toggle[]
assert["button toggle on" ("solid","solid") s,b.show]
s:(b.toggle["transparent"],b.toggle["transparent"],b.toggle["transparent"])
assert["button toggle with mode" ("none","transparent","none") s]
s:(b.toggle["solid" 1],b.toggle["solid" 37],b.toggle["solid" 0],b.toggle["solid" 0])
assert["button toggle with value" ("solid","solid","none","none") s]
s:(b.toggle["transparent" b.show],b.toggle["transparent" "solid"])
assert["button toggle with svalue" ("none","transparent") s]

#######################################
#
#  Field
#
#######################################

deck:readdeck[]
card:deck.card
f:card.add["field"]

dattr:()
dattr.text:      ""
dattr.scroll:    0
dattr.border:    1
dattr.scrollbar: 0
dattr.style:     "rich"
dattr.align:     "left"
on fieldattrs x do
	r:()
	r.text:      x.text
	r.scroll:    x.scroll
	r.border:    x.border
	r.scrollbar: x.scrollbar
	r.style:     x.style
	r.align:     x.align
end
assert["field default attributes" dattr fieldattrs[f]]

assert["field empty value"
	insert text font arg with "" "" "" end
	f.value
]

f.text:v:"just some\nplain text?"
assert["field write text, read text" v f.text]
assert["field write text, read value"
	insert text font arg with v "" "" end
	f.value
]

f.value:v:insert text font with "information\n" "menu" "highly relevant stuff." "" end
assert["field write table, read text" "information\nhighly relevant stuff." f.text]
assert["field write table, read value" (update arg:"" from v) f.value]

cf:card.add["field"]
cf.style:"code"
assert["code fields default to a monospaced font" deck.fonts.mono cf.font]
cf.value:f.value
assert["non-rich text fields coalesce values into plain text"
	insert text font arg with "information\nhighly relevant stuff." "" "" end
	cf.value
]

cf:card.add["field"]
cf.value:v
cf.style:"plain"
assert["non-rich text fields even coalesce existing values"
	insert text font arg with "information\nhighly relevant stuff." "" "" end
	cf.value
]

#######################################
#
#  Slider
#
#######################################

deck:readdeck[]
card:deck.card
s:card.add["slider"]

dattr:()
dattr.value:    0
dattr.step:     1
dattr.interval: 0,100
dattr.format:   "%f"
dattr.style:    "horiz"
on sliderattrs x do
	r:()
	r.value:    x.value
	r.step:     x.step
	r.interval: x.interval
	r.format:   x.format
	r.style:    x.style
end
assert["slider default attributes" dattr sliderattrs[s]]

s.interval: 70,30
assert["slider normalize interval"          30,70 s.interval]
assert["slider write interval clamps value" 30    s.value]

s.value:999
assert["slider write value clamps to interval" 70 s.value]

s.step:0.25
s.value:40.6
assert["slider write value respects step" 40.5 s.value]
s.step:2
assert["slider change step reclamps value" 40 s.value]

s.interval:-2,3.5
s.step:.001
s.value:-1.32
writedeck["temp.deck" deck]
deck:readdeck["temp.deck"]
assert["slider round-trips with custom step" -1.32 deck.card.widgets.slider1.value]

#######################################
#
#  Grid
#
#######################################

deck:readdeck[]
card:deck.card
g:card.add["grid"]

dattr:()
dattr.value:     table ()
dattr.scroll:    0
dattr.row:       -1
dattr.headers:   1
dattr.scrollbar: 1
dattr.lines:     1
dattr.bycell:    0
dattr.widths:    ()
dattr.format:    ""
on gridattrs x do
	r:()
	r.value:     x.value
	r.scroll:    x.scroll
	r.row:       x.row
	r.headers:   x.headers
	r.scrollbar: x.scrollbar
	r.lines:     x.lines
	r.bycell:    x.bycell
	r.widths:    x.widths
	r.format:    x.format
end
assert["grid default attributes" dattr gridattrs[g]]

dattr.value:     g.value:   insert a b with 11 33 22 44 end
dattr.scroll:    g.scroll:  42
dattr.row:       g.row:     1
dattr.headers:   g.headers: 0
dattr.scrollbar: g.scrollbar: 0
dattr.lines:     g.lines:   0
dattr.bycell:    g.bycell:  1
dattr.widths:    g.widths:  11,22,33
dattr.format:    g.format:  "issj"
assert["grid mutable attributes" dattr gridattrs[g]]

dattr.value:table 69  g.value: 69
dattr.scroll:0        g.scroll: -5
dattr.row:-1          g.row: -9
dattr.headers:0       g.headers:()
dattr.scrollbar:1     g.scrollbar:23
dattr.lines:1         g.lines:999
dattr.bycell:1        g.bycell:9999
dattr.widths:0,0,0    g.widths:"ABC"
dattr.format:"123"    g.format:123
assert["grid attribute sanitizing" dattr gridattrs[g]]

g.widths:300 take 25
assert["grid cap widths list" 255 (count g.widths)]

g.value:insert a b with 11 44 22 55 33 55 end
g.row:1
assert["grid rowvalue" (("a","b")dict 22,55) g.rowvalue]
g.row:-999
assert["grid empty rowvalue" (()dict()) g.rowvalue]

assert["grid default colindex" -1 g.col]
g.col:1
assert["grid write colindex" ("b",1) g.colname,g.col]
g.colname:"zorch"
assert["grid write invalid colname" (0,-1) g.colname,g.col]
g.colname:"a"
assert["grid write valid colname" ("a",0) g.colname,g.col]
g.row:2
assert["grid read cell" (0,2) g.cell]
assert["grid cellvalue" 33 g.cellvalue]
g.cell:("b",1)
assert["grid write cellvalue" (1,1) g.cell]
g.colname:"bogus"
assert["grid cellvalue when no column set" 0 g.cellvalue]

g.row:1
g.value:insert a with end
assert["grid row clamped empty" -1 g.row]

g.value:insert a with 11 22 33 end
g.row:15
assert["grid row clamped max" 2 g.row]

g.value:insert a b with 11 22 33 44 end
g.row:1
g.col:0
g.rowvalue:("b","a")dict 99,88
assert["grid write rowvalue" insert a b with 11 22 88 99 end g.value]
g.cellvalue:101
assert["grid write cellvalue" insert a b with 11 22 101 99 end g.value]
g.row:-1
g.cellvalue:99999
assert["grid write cellvalue with invalid row index" insert a b with 11 22 101 99 end g.value]

#######################################
#
#  Font
#
#######################################

deck:readdeck[]
f:deck.fonts.menu

assert["font size" (16,13) f.size]
assert["font space" 1 f.space]
assert["font textsize" (61,26) f.textsize["A Quick\nBrown Fox"]]
f.space:3
assert["font extended" (79,26) f.textsize["A Quick\nBrown Fox"]]

assert_image["font read char"
	((list 0,0,0,0,0,0),
	 (list 0,1,1,1,1,0),
	 (list 1,1,0,0,1,1),
	 (list 1,1,0,0,1,1),
	 (list 1,1,0,0,1,1),
	 (list 1,1,1,1,1,1),
	 (list 1,1,0,0,1,1),
	 (list 1,1,0,0,1,1),
	 (list 1,1,0,0,1,1),
	 (list 1,1,0,0,1,1),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0))
	f.A
]

f.A:f.w
assert_image["font copy char"
	((list 0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0),
	 (list 1,1,0,0,1,1,0,0,1,1),
	 (list 1,1,0,0,1,1,0,0,1,1),
	 (list 1,1,0,0,1,1,0,0,1,1),
	 (list 1,1,0,0,1,1,0,0,1,1),
	 (list 1,1,0,0,1,1,0,0,1,1),
	 (list 1,1,0,0,1,1,0,0,1,0),
	 (list 1,1,1,1,1,1,1,1,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0))
	f[(first "%a" parse "A")-32]
]

f.size:20,18
assert_image["font resize"
	((list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0),
	 (list 0,1,1,1,1,0),
	 (list 1,0,0,0,1,1),
	 (list 0,1,1,1,1,1),
	 (list 1,1,0,0,1,1),
	 (list 1,1,0,0,1,1),
	 (list 1,1,0,0,1,1),
	 (list 0,1,1,1,1,1),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0),
	 (list 0,0,0,0,0,0))
	f.a
]

f.size:0
assert["font minimum size" (1,1) f.size]
f.size:-.3,2.9
assert["font bogus size" (1,2) f.size]

# oob accesses:
f[96]:image[]
f[-1]:image[]

#######################################
#
#  Sound
#
#######################################

deck:readdeck[]
snd:sound[30]

assert["sound duration" (30/8000) snd.duration]
assert["sound size"     30 snd.size]
snd.size:12
assert["sound shrink"   12 snd.size]
snd.size:50
assert["sound grow"     50 snd.size]
snd[49]:126
assert["sound write"    126 snd[49]]
assert["sound oob 1"    0 snd[-5]]
assert["sound oob 2"    0 snd[9999]]

snd.size:8000
each x in range snd.size
	snd[x]:16*sin (440/8000)*2*pi*x # A-4, 440hz
end

if !sys.platform~"web"
	write["temp.wav" snd]
	assert_file["write wav" "tests/dom/a4.wav" "temp.wav"]

	w:read["tests/dom/a4.wav" 10]
	assert["read valid wav size" 7990  w.size]
	assert["read valid wav data" (-4,-9,-13,-15,-15) w[0,5]]

	w:read["tests/dom/a.wav"]
	assert["read invalid wav type" "sound" (typeof w)]
	assert["read invalid wav size" 0       w.size]
end

assert["sound bulk read" (-4,-9,-13,-15,-15) snd[10,5]]

snd.size:5
snd[0,5]:11,22,33,44,126
assert["sound bulk write entire" (11,22,33,44,126) snd[0,snd.size]]
snd[1,2]:99,88,77
assert["sound splice" (11,99,88,77,44,126) snd[0,snd.size]]
snd[1,3]:()
assert["sound delete" (11,44,126) snd[0,snd.size]]
snd[2,0]:110,-36
assert["sound insert" (11,44,110,-36,126) snd[0,snd.size]]

assert["sound encode" "%%SND0Cyxu3H4=" snd.encoded]
assert["sound decode" (11,44,110,-36,126) sound["%%SND0Cyxu3H4="][0,5]]

snd.size:5
snd[0,5]:11,22,33,44,126
snd.map[(22,33) dict 44,55 77]
assert["sound map"        (77,44,55,77,77)    snd[0,5]]
snd.map[(44,55) dict -37,-120]
assert["sound map signed" (77,-37,-120,77,77) snd[0,5]]

assert["sound histogram" ("%j" parse "{77:3,-120:1,-37:1}") snd.hist]

#######################################
#
#  Patterns
#
#######################################

deck:readdeck[]
p:deck.patterns
c:deck.card.add["canvas"]

smile:"%%IMG0AAgACH6BpaWBmcN+"
p[12]:image[smile]
assert["pattern write/read" smile p[12].encoded]
c.size:10,10
c.pattern:12
c.fill[1,5]
c.invert[]
assert_image["custom pattern fill"
	((list 1,0,0,0,0,0,0,1,1,0),
	 (list 0,1,1,1,1,1,1,0,0,1),
	 (list 0,1,0,1,1,0,1,0,0,1),
	 (list 0,1,0,1,1,0,1,0,0,1),
	 (list 0,1,1,1,1,1,1,0,0,1),
	 (list 0,1,1,0,0,1,1,0,0,1),
	 (list 0,0,1,1,1,1,0,0,0,0),
	 (list 1,0,0,0,0,0,0,1,1,0),
	 (list 1,0,0,0,0,0,0,1,1,0),
	 (list 0,1,1,1,1,1,1,0,0,1))
	c.copy[]
]

assert["pattern anim default" (13,9,5,1,5,9) p[28]]
p[28]:range 20
assert["pattern anim write" (0,1,2,3,4,5,6,7) p[28]]
p[29]:27,28,31,32
assert["pattern anim may not include animated colors" (27,0,0,32) p[29]]

peachpuff:"%h" parse "FFDAB9"
p[38]:peachpuff
assert["pattern color write/read" peachpuff p[38]]
assert["pattern tolerate bogus write" 420 p[3]:420]

op:readdeck[].patterns
assert["pattern color isolation" 202 op[38]]

#######################################
#
#  Canvas
#
#######################################

deck:readdeck[]
card:deck.card
c:card.add["canvas"]
assert["create new deck and canvas" "canvas" (typeof c)]

dattr:()
dattr.border:  1
dattr.brush:   0
dattr.pattern: 1
dattr.size:    100,100
dattr.font:    deck.fonts.body
on cattrs x do
	r:()
	r.border:  x.border
	r.brush:   x.brush
	r.pattern: x.pattern
	r.size:    x.size
	r.font:    x.font
end
assert["canvas default attributes" dattr cattrs[c]]

dattr.border:  c.border:  0
dattr.brush:   c.brush:   5
dattr.pattern: c.pattern: 23
dattr.size:    c.size:    20,15
dattr.font:    c.font:    deck.fonts.menu
assert["canvas mutable attributes" dattr cattrs[c]]

dattr.border:1              c.border: 23
dattr.brush:0               c.brush: -1
dattr.pattern:0             c.pattern: -1
dattr.size:0,0              c.size: 5
dattr.font:deck.fonts.body  c.font: "fake"
assert["canvas attribute sanitizing" dattr cattrs[c]]

# pre-init a background color,
# to demonstrate clipping is working.
c.size:10,10
c.pattern:3
c.fill[1,1]
c.clip[1,1 8,8]

c.pattern:1
c.line[0,0 10,10]
assert_image["canvas simple line"
	((list 3,3,3,3,3,3,3,3,3,3),
	 (list 3,1,3,3,3,3,3,3,3,3),
	 (list 3,3,1,3,3,3,3,3,3,3),
	 (list 3,3,3,1,3,3,3,3,3,3),
	 (list 3,3,3,3,1,3,3,3,3,3),
	 (list 3,3,3,3,3,1,3,3,3,3),
	 (list 3,3,3,3,3,3,1,3,3,3),
	 (list 3,3,3,3,3,3,3,1,3,3),
	 (list 3,3,3,3,3,3,3,3,1,3),
	 (list 3,3,3,3,3,3,3,3,3,3))
	c.copy[]
]

c.pattern:9
c.fill[2,1]
assert_image["canvas patterned fill"
	((list 3,3,3,3,3,3,3,3,3,3),
	 (list 3,1,9,9,9,9,9,9,9,3),
	 (list 3,3,1,9,9,9,9,9,9,3),
	 (list 3,3,3,1,9,9,9,9,9,3),
	 (list 3,3,3,3,1,9,9,9,9,3),
	 (list 3,3,3,3,3,1,9,9,9,3),
	 (list 3,3,3,3,3,3,1,9,9,3),
	 (list 3,3,3,3,3,3,3,1,9,3),
	 (list 3,3,3,3,3,3,3,3,1,3),
	 (list 3,3,3,3,3,3,3,3,3,3))
	c.copy[]
]

c.invert[0,0 7,10]
assert_image["canvas invert pattern"
	((list 3,3,3,3,3,3,3,3,3,3),
	 (list 3,0,1,0,0,0,1,9,9,3),
	 (list 3,1,0,0,1,0,0,9,9,3),
	 (list 3,0,1,0,0,0,1,9,9,3),
	 (list 3,1,0,1,0,0,0,9,9,3),
	 (list 3,1,1,0,0,0,1,9,9,3),
	 (list 3,1,1,1,0,1,0,9,9,3),
	 (list 3,1,1,0,1,1,1,1,9,3),
	 (list 3,1,0,1,1,1,1,3,1,3),
	 (list 3,3,3,3,3,3,3,3,3,3))
	c.copy[]
]

c.clear[0,0 5,10]
assert_image["canvas partial clear"
	((list 3,3,3,3,3,3,3,3,3,3),
	 (list 3,0,0,0,0,0,1,9,9,3),
	 (list 3,0,0,0,0,0,0,9,9,3),
	 (list 3,0,0,0,0,0,1,9,9,3),
	 (list 3,0,0,0,0,0,0,9,9,3),
	 (list 3,0,0,0,0,0,1,9,9,3),
	 (list 3,0,0,0,0,1,0,9,9,3),
	 (list 3,0,0,0,0,1,1,1,9,3),
	 (list 3,0,0,0,0,1,1,3,1,3),
	 (list 3,3,3,3,3,3,3,3,3,3))
	c.copy[]
]

c[5,5]:33
c[5,6]:32
c.invert[]
assert_image["invert colors"
	((list 3,3,3,3,3,3,3,3,3,3),
	 (list 3,1,1,1,1,1,0,0,0,3),
	 (list 3,1,1,1,1,1,1,0,1,3),
	 (list 3,1,1,1,1,1,0,0,0,3),
	 (list 3,1,1,1,1,1,1,0,1,3),
	 (list 3,1,1,1,1,0,0,0,0,3),
	 (list 3,1,1,1,1,1,1,0,1,3),
	 (list 3,1,1,1,1,0,0,0,0,3),
	 (list 3,1,1,1,1,0,0,1,0,3),
	 (list 3,3,3,3,3,3,3,3,3,3))
	c.copy[]
]

c.clip[]
c.clear[]
c.size:13,11
c.clip[1,1 11,9]
c.pattern:1
c.poly[5,-3 10,9 1,8]
assert_image["canvas clipped triangle"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,1,1,1,0,0,0,0,0,0),
	 (list 0,0,0,0,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,1,0,0,0,0),
	 (list 0,0,1,1,1,1,1,1,1,0,0,0,0),
	 (list 0,0,1,1,1,1,1,1,1,1,0,0,0),
	 (list 0,1,1,1,1,1,1,1,1,1,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,1,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

c.clear[]
c.brush:1
c.line[5,-3 10,9 1,6]
assert_image["canvas clipped polyline"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,1,1,1,0,0,0,0),
	 (list 0,0,0,0,0,0,1,1,1,0,0,0,0),
	 (list 0,0,0,0,0,0,0,1,1,1,0,0,0),
	 (list 0,0,0,0,0,0,0,1,1,1,0,0,0),
	 (list 0,1,1,0,0,0,0,1,1,1,0,0,0),
	 (list 0,1,1,1,1,1,0,0,1,1,1,0,0),
	 (list 0,1,1,1,1,1,1,1,1,1,1,0,0),
	 (list 0,0,0,1,1,1,1,1,1,1,1,1,0),
	 (list 0,0,0,0,0,0,1,1,1,1,1,1,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

c.clear[]
c.line[(list 7,-3),(list 1,6),(list 10,9)]
assert_image["canvas clipped polyline list"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,1,1,1,0,0,0,0,0,0,0),
	 (list 0,0,0,1,1,1,0,0,0,0,0,0,0),
	 (list 0,0,1,1,1,0,0,0,0,0,0,0,0),
	 (list 0,1,1,1,0,0,0,0,0,0,0,0,0),
	 (list 0,1,1,1,0,0,0,0,0,0,0,0,0),
	 (list 0,1,1,1,1,1,0,0,0,0,0,0,0),
	 (list 0,1,1,1,1,1,1,1,1,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,1,1,1,0,0),
	 (list 0,0,0,0,0,0,1,1,1,1,1,1,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]
c.brush:0

c.clear[]
c.box[3,8 5,5]
c.box[9,3 5,5]
c.box[2,2 1,5]
c.box[5,2 -2,5]
assert_image["canvas clipped boxes"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,1,0,1,1,0,0,0,0,0,0,0),
	 (list 0,0,1,0,1,1,0,0,0,1,1,1,0),
	 (list 0,0,1,0,1,1,0,0,0,1,0,0,0),
	 (list 0,0,1,0,1,1,0,0,0,1,0,0,0),
	 (list 0,0,1,0,1,1,0,0,0,1,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,1,1,1,0),
	 (list 0,0,0,1,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,1,0,0,0,1,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

c.clear[]
c.rect[3,8 5,5]
c.rect[9,3 5,5]
c.rect[2,2 1,5]
c.rect[5,2 -2,5]
assert_image["canvas clipped rects"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,1,0,1,1,0,0,0,0,0,0,0),
	 (list 0,0,1,0,1,1,0,0,0,1,1,1,0),
	 (list 0,0,1,0,1,1,0,0,0,1,1,1,0),
	 (list 0,0,1,0,1,1,0,0,0,1,1,1,0),
	 (list 0,0,1,0,1,1,0,0,0,1,1,1,0),
	 (list 0,0,0,0,0,0,0,0,0,1,1,1,0),
	 (list 0,0,0,1,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

c.clear[]
c.rect[1,1 8,5]
c.pattern:2
c.line[1,5 8,1]
t:c.copy[0,0 8,5]
c.paste[t 4,5]
assert_image["canvas copy and paste"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,1,1,1,1,1,1,1,2,0,0,0,0),
	 (list 0,1,1,1,1,1,2,2,1,0,0,0,0),
	 (list 0,1,1,1,2,2,1,1,1,0,0,0,0),
	 (list 0,1,2,2,1,1,1,1,1,0,0,0,0),
	 (list 0,2,1,1,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,1,1,1,1,1,1,1,0),
	 (list 0,0,0,0,0,1,1,1,1,1,2,2,0),
	 (list 0,0,0,0,0,1,1,1,2,2,1,1,0),
	 (list 0,0,0,0,0,1,2,2,1,1,1,1,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

c.paste[t (1,1,11,9)]
assert_image["canvas paste scaled"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,1,1,1,1,0),
	 (list 0,0,0,1,1,1,1,1,1,1,1,1,0),
	 (list 0,0,0,1,1,1,1,1,1,1,2,2,0),
	 (list 0,0,0,1,1,1,1,1,1,1,2,2,0),
	 (list 0,0,0,1,1,1,1,2,2,2,1,1,0),
	 (list 0,0,0,1,1,1,1,2,2,2,1,1,0),
	 (list 0,0,0,1,2,2,2,1,1,1,1,1,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

c.clear[]
c.clip[2,3 6,5]
c.paste[t (1,1,11,9)]
assert_image["canvas paste respects clip"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,1,0,0,0,0,0),
	 (list 0,0,0,1,1,1,1,2,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

c.clip[1,1 11,9]
c.clear[]
c.pattern:1
c.text["abc" 1,1]
assert_image["canvas clipped text"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,1,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,1,0,0,0,0,0,0),
	 (list 0,0,1,1,0,0,1,1,1,0,0,0,0),
	 (list 0,0,0,0,1,0,1,0,0,1,0,1,0),
	 (list 0,0,1,1,1,0,1,0,0,1,0,1,0),
	 (list 0,1,0,0,1,0,1,0,0,1,0,1,0),
	 (list 0,0,1,1,1,0,1,1,1,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

c.clear[]
c.size:6,6
c.pattern:1 c.box[3,3 3,3 "bottom_right"]
c.pattern:2 c.box[3,3 3,3 "bottom_left" ]
c.pattern:3 c.box[3,3 3,3 "top_right"   ]
c.pattern:4 c.box[3,3 3,3 "top_left"    ] # (default)
assert_image["canvas anchor layout"
	((list 1,1,1,2,2,2),
	 (list 1,0,1,2,0,2),
	 (list 1,1,1,2,2,2),
	 (list 3,3,3,4,4,4),
	 (list 3,0,3,4,0,4),
	 (list 3,3,3,4,4,4))
	c.copy[]
]

assert["canvas read at coords" 4 c[3,3]]
c[3,3]:6
assert["canvas write at coords" 6 c[3,3]]

deck:readdeck[]
card:deck.card
c:card.add["canvas"]
assert["canvas default scale" 1.0 c.scale]
c.scale:5
c.size:25,50
assert["canvas rescaled buffer size 1"  (5,10) c.copy[].size]
assert["canvas rescaled buffer lsize 1" (5,10) c.lsize]
c.scale:2
assert["canvas rescaled buffer size 2"  (13,25) c.copy[].size]
assert["canvas rescaled buffer lsize 2" (13,25) c.lsize]
c.size:0,0
assert["empty canvas lsize" (0,0) c.lsize]

c.size:50,30
c.scale:2
c.lsize:100,17
assert["canvas rescale via logical size" (200,34,100,17) c.size,c.lsize]

deck:readdeck[]
card:deck.card
c:card.add["canvas"]
c.size:20,13
rt:rtext.cat[
	rtext.make["Aa" "menu"]
	rtext.make["A"  "body" "link"]
]
c.text[rt 1,1]
assert_image["canvas rich text"
	((list  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
	 (list  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
	 (list  0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
	 (list  0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0),
	 (list  0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0),
	 (list  0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0),
	 (list  0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0),
	 (list  0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1),
	 (list  0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1),
	 (list  0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1),
	 (list  0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0),
	 (list  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19,19,19,19,19),
	 (list  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
	c.copy[]
]

c.size:5,5
c.clear[]
c.pattern:13
c.fill[]
c.invert[]
c.pattern:1
c.box[0,0 5,5]
i:c.copy[]
c.size:11,9
c.clear[]
rt:rtext.cat[
	rtext.make["b" "mono"]
	rtext.make["" "" i]
]
c.text[rt 0,-2]
assert_image["canvas rich text with inline image"
	((list 0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0),
	 (list 1,0,0,0,0,0,0,0,0,0,0),
	 (list 1,0,0,0,0,0,1,1,1,1,1),
	 (list 1,1,1,1,0,0,1,0,1,0,1),
	 (list 1,0,0,0,1,0,1,1,0,1,1),
	 (list 1,0,0,0,1,0,1,0,1,0,1),
	 (list 1,0,0,0,1,0,1,1,1,1,1),
	 (list 1,1,1,1,0,0,0,0,0,0,0))
	c.copy[]
]

c.clear[]
c.size:15,9
c.text["hi." 0,0,15,11 "center"]
assert_image["canvas plaintext centered"
	((list 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,1,0,0,0,0,0,1,0,0,0,0,0,0),
	 (list 0,0,1,0,0,0,0,0,0,0,0,0,0,0,0),
	 (list 0,0,1,1,1,0,0,1,1,0,0,0,0,0,0),
	 (list 0,0,1,0,0,1,0,0,1,0,0,0,0,0,0),
	 (list 0,0,1,0,0,1,0,0,1,0,0,0,0,0,0),
	 (list 0,0,1,0,0,1,0,0,1,0,0,0,0,0,0),
	 (list 0,0,1,0,0,1,0,0,1,0,1,0,0,0,0),
	 (list 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

deck:readdeck[]
card:deck.card
c:card.add["canvas"]
c.size:5,2
c.pattern:2
c.fill[]
c[0,0]:c[1,1]:3
imga:c.copy[]
c.size:4,4
c.clear[]
c.pattern:19
c.fill[]
c.invert[]
imgb:c.copy[]
c.size:10,9
c.clear[]
c.pattern:1
c.rect[3,3 c.size-6]
c.clip[1,1 c.size-2]
c.merge[imga imgb]
assert_image["canvas merge"
	((list 0,0,0,0,0,0,0,0,0,0),
	 (list 0,3,2,2,2,2,3,2,2,0),
	 (list 0,2,2,2,2,3,2,2,2,0),
	 (list 0,3,2,1,0,1,0,2,2,0),
	 (list 0,2,2,1,0,1,0,2,2,0),
	 (list 0,3,2,1,0,1,0,2,2,0),
	 (list 0,2,2,2,2,3,2,2,2,0),
	 (list 0,3,2,2,2,2,3,2,2,0),
	 (list 0,0,0,0,0,0,0,0,0,0))
	c.copy[]
]

horiz:image["%%IMG2AAgACAAIAQgCCAMIBAgFCAYIBwg="]
vert :image["%%IMG1AAgACAABAgMEBQYHAAECAwQFBgcAAQIDBAUGBwABAgMEBQYHAAECAwQFBgcAAQIDBAUGBwABAgMEBQYHAAECAwQFBgc="]
c.size:horiz.size
c.clear[]
c.paste[horiz]
c.merge[">" vert]
assert["canvas > merge" "%%IMG0AAgACACAwODw+Pz+" c.copy[].encoded]

# ensure bounds checks work:
c.merge[512 take image[1,1]]

deck:readdeck[]
c:deck.card.add["canvas"]
c.size:5,7
c.rect[0,7 5,-2.3]
assert["rect fill negative rounding" "%%IMG2AAUABwAeAQU=" c.copy[].encoded]

c:deck.card.add["canvas"]
c.size:3,3
c.pattern:1
c.fill[]
c[1,1]:29
c.invert[]
assert["canvas invert animated pattern" "%%IMG0AAMAAwBAAA==" c.copy[].encoded]

c:deck.card.add["canvas"]
r:rtext.make["some "],rtext.make["rtext!" "menu"]
assert["canvas rtext size"              ( 58,13) c.textsize[r]]
c.font:"mono"
assert["canvas rtext size w/ font"      ( 63,13) c.textsize[r]]
assert["canvas plaintext size"          (114,11) c.textsize["Some words to wrap!"]]
assert["canvas plaintext size w/ width" ( 30,55) c.textsize["Some words to wrap!" 30]]

c:deck.card.add["canvas"]
i:image["%%IMG1AAcABwABAQEBAQABJyEhISMBASclJCMjAQEnJCUjIwEBKCgoIyMBASgoKCgjAQABAQEBAQE="]
c.segment[i 1,1,9,9 2,2,3,3]
assert["canvas segment scale" "%%IMG2AAsACwANAQcAAwEBJwEhBSMBAQEAAgEBJwElASQBJQEkASMCAQEAAgEBJwEkASUBJAElASMCAQEAAgEBJwElASQBJQEkASMCAQEAAgEBJwEkASUBJAElASMCAQEAAgEBKAUjAgEBAAIBASgGIwEBAQADAQgADA==" c.copy[0,0 11,11].encoded]
c.clear[]
c.segment[i 1,1,-5,-2.3 2,2,3,3]
assert["canvas segment minscale" "%%IMG1AAYABgAAAAAAAAAAAQEBAAABJyEjAQABKCMjAQABKCgjAQAAAQEBAQ==" c.copy[0,0 6,6].encoded]

#######################################
#
#  Deck
#
#######################################

deck:readdeck[]
dattr:()
dattr.version:  1
dattr.locked:   0
dattr.name:     ""
dattr.author:   ""
dattr.script:   ""
dattr.patterns: "patterns"
dattr.sounds:   "dict"
dattr.fonts:    "dict"
dattr.cards:    "dict"
dattr.card:     "card"
on deckattrs x do
	r:()
	r.version:  x.version
	r.locked:   x.locked
	r.name:     x.name
	r.author:   x.author
	r.script:   x.script
	r.patterns: typeof x.patterns
	r.sounds:   typeof x.sounds
	r.fonts:    typeof x.fonts
	r.cards:    typeof x.cards
	r.card:     typeof x.card
end
assert["deck default attributes and types" dattr deckattrs[deck]]

s1:deck.add[sound[]]
s2:deck.add[sound[20]]
assert["deck added sounds" (("sound1","sound2")dict s1,s2) deck.sounds]

r:deck.remove[s1]
assert["deck removed sound" (().sound2:s2) deck.sounds]
assert["deck removed sound success" 1 r]

c1:deck.card
c2:deck.add["card" "two"]
c3:deck.add["card" "three"]
assert["deck added cards" (("home","two","three")dict c1,c2,c3) deck.cards]

deck.card:2
assert["navigate deck by index" "three" deck.card.name]
deck.card:c1
assert["navigate deck by value" "home" deck.card.name]
deck.card:"two"
assert["navigate deck by name" "two" deck.card.name]
deck.card:"First"
assert["navigate deck relative- first" "home" deck.card.name]
deck.card:"Next"
assert["navigate deck relative- next" "two" deck.card.name]
deck.card:"Last"
assert["navigate deck relative- last" "three" deck.card.name]
deck.card:"Prev"
assert["navigate deck relative- prev" "two" deck.card.name]
deck.card:"Back"
assert["navigate deck relative- back 1" "three" deck.card.name]
deck.card:"Back"
assert["navigate deck relative- back 2" "two" deck.card.name]
deck.card:"Back"
assert["navigate deck relative- back 3" "home" deck.card.name]

r:deck.remove[c2]
assert["deck removed card" (("home","three")dict c1,c3) deck.cards]
assert["deck removed card success" 1 r]
c2.index:3
assert["removed cards are inert" (("home","three")dict c1,c3) deck.cards]
assert["removed cards are inert" 0 c2.name]

builtins:deck.fonts,()
f1:deck.add["font"]
f2:deck.add["font" 13,13 "chancery"]
assert["deck added font" (builtins,("font1","chancery")dict f1,f2) deck.fonts]

r:deck.remove[f1]
assert["deck removed font" (builtins,().chancery:f2) deck.fonts]
assert["deck removed font success" 1 r]

r:deck.remove[deck.fonts.menu]
assert["deck does not allow removing builtin fonts" 4 (count deck.fonts)]
assert["deck does not allow removing builtin fonts fail" 0 r]

deck.card:"home"
deck.remove[deck.card]
assert["removing the current card from the deck" "three" deck.card.name]

deck.remove[deck.card]
assert["cannot remove the last card in the deck" 1 (count deck.cards)]

deck:readdeck[]
deck.name:"everything but the sink"
deck.author:"just some guy"
deck.locked:1
o:deck.add["card" "other"]
deck.script:"show[\"</script> is a perfectly valid string in Lil.\"]"
deck.card.add["field" "output"].text:"A Sentence"
icon:image[2,2].map[list 23]
r:deck.card.add["field" "richval"]
r.value:rtext.cat[rtext.make["Words" "mono"] rtext.make["" "" icon]]
r.font:"mono"
deck.card.add["button" "go"]
deck.card.add["button" "widget with :, { and } in the name"]
c:o.add["canvas" "drawring"]
c.size:30,30
c.poly[15,0 30,29 4,15]
o.add["grid" "things"].value:insert a b with 11 "One" 22 "Two" end
s:deck.add[sound[] "short"]
s[0,0]:126+range 5
f:deck.add["font" 2,3 "dingus"]
glyph:image[2,3]
glyph[0,0]:1 glyph[1,1]:1 glyph[0,2]:1
f["A"]:glyph
deck.patterns[28]:10,20,5
deck.patterns[2]:image["%%IMG0AAgACAsMDQ4PEBES"]
writedeck["temp.deck" deck]
assert_file["write a basic kitchen sink." "tests/dom/sink1.deck" "temp.deck"]

deck:readdeck["tests/dom/sink1.deck"]
assert["read a deck" "deck" typeof deck]
assert["read a deck: metadata" ("everything but the sink","just some guy") (deck.name,deck.author)]
assert["read a deck: card names" ("home","other") (keys deck.cards)]
assert["read a deck: script" "show[\"</script> is a perfectly valid string in Lil.\"]" deck.script]
assert["read a deck: widget names" ("output","richval","go","widget with :, { and } in the name") (keys deck.card.widgets)]
assert["read a deck: widget font" (deck.fonts.mono) (deck.card.widgets.richval.font)]
assert["read a deck: sounds" (126,127,-128,-127,-126,5) (deck.sounds.short[0,5],deck.sounds.short.size)]
assert_image["read a deck: inline rtext image"
	((list 23,23),
	 (list 23,23))
	deck.card.widgets.richval.value.arg[1]
]
assert_image["read a deck: custom font glyph"
	((list 1,0),
	 (list 0,1),
	 (list 1,0))
	deck.fonts.dingus["A"]
]
assert["read a deck: custom animated pattern:" (10,20,5)                 deck.patterns[28]        ]
assert["read a deck: custom regular pattern:"  "%%IMG0AAgACAsMDQ4PEBES"  deck.patterns[ 2].encoded]

deck:readdeck["tests/dom/bare.deck"]
assert["read a bare deck" "deck" typeof deck]
assert["read a bare deck: widget names" ("pusher","outfield","expenses","frame") (keys deck.card.widgets)]

deck:readdeck[]
b:deck.card.add["button"]
assert["deck remove widget"            1 deck.remove[b]]
assert["sanity check widget removed"  () keys deck.card.widgets]
assert["sanity check widget inert"     0 b.name]
assert["deck remove inert widget"      0 deck.remove[b]]

#######################################
#
#  Names and Indices
#
#######################################

deck:readdeck[]
c1:deck.card
c2:deck.add["card"]
c3:deck.add["card"]
assert["build unique card names" ("home","card1","card2") (c1.name,c2.name,c3.name)]
c3.name:"home"
assert["set unique card names" "home1" c3.name]
assert["confirm renamed card keys" ("home","card1","home1") (keys deck.cards)]
assert["confirm renamed card lookup" c3 deck.cards.home1]

assert["read card indices" (0,1,2) (c1.index,c2.index,c3.index)]
c2.index:0
assert["move card to start" ("card1","home","home1") (keys deck.cards)]
c2.index:2
assert["move card to end"   ("home","home1","card1") (keys deck.cards)]

card:deck.card
f1:card.add["field"]
f2:card.add["field" "unique"]
f3:card.add["field"]
assert["build unique widget names" ("field1","unique","field2") (f1.name,f2.name,f3.name)]
f3.name:"unique"
assert["set unique widget names" "unique1" f3.name]
assert["confirm renamed widget keys" ("field1","unique","unique1") (keys card.widgets)]
assert["confirm renamed widget lookup" f3 card.widgets.unique1]

assert["read widget indices" (0,1,2) (f1.index,f2.index,f3.index)]
f3.index:0
assert["move widget to back"  ("unique1","field1","unique") (keys card.widgets)]
f3.index:2
assert["move widget to front" ("field1","unique","unique1") (keys card.widgets)]
f2.index:1
assert["move widget identity" ("field1","unique","unique1") (keys card.widgets)]
f2.index:99
assert["move widget boundary" ("field1","unique1","unique") (keys card.widgets)]

deck:readdeck[]
c1:deck.card
c1.add["button" "clickme"]
c2:deck.add[c1]
assert["add card to deck: cardlist" ("home","card1") (keys deck.cards)]
assert["add card to deck: wids"     (list "clickme") (keys c2.widgets)]
c3:deck.add[c1 "named"]
assert["add card to deck with name" ("home","card1","named") (keys deck.cards)]

#######################################
#
#  Events
#
#######################################

deck:readdeck[]
card:deck.card
f:card.add["field" "quantity"]
b:card.add["button" "go"]
b.script:"on click do quantity.text:3*quantity.text end"
f.text:2
b.event["click"]
assert["update field by button click" "6" f.text]
b.event["click"]
assert["ensure events are repeatable" "18" f.text]

card.script:"on navigate x do quantity.text:\"%s???\" format x end"
card.event["navigate" "left"]
assert["update field by card navigate" "left???" f.text]

deck:readdeck[]
deck.script:""
c:deck.add["card" "sharedname"]
deck.script:"on fetch do typeof sharedname end"
b:c.add["button" "sharedname"]
f:c.add["field" "output"]
b.script:"on click do output.text: (typeof sharedname),\",\",fetch[] end"
b.event["click"]
assert["shadowing autobound variables" "button,card" f.text]

deck:readdeck[]
card:deck.card
field:card.add["field" "target"]
card.script:"on change x do target.text:\"one\",x end"
field.script:"on change x do target.text:\"nope\" send change[x,\"two\"] end"
field.event["change" "three"]
assert["event bubbling updates" "onethreetwo" field.text]

deck:readdeck[]
card:deck.card
deck.add["card" "other"]
field:card.add["field" "output"]
field.script:"on go x do output.text:\"worked!\",x send go[1] end    on change do go[0] end"
field.event["change"]
assert["builtin shadowing: side-effect" "worked!0" field.text]
assert["builtin shadowing: forwarding"  "other" deck.card.name]

deck:readdeck[]
card:deck.card
card.script:"on click do home.name:\"zeppo\" end"
button:card.add["button" "boop"]
button.script:"on syntax error ignore me" # this will not execute!
button.event["click"]
assert["ignore invalid scripts" "zeppo" card.name]

deck:readdeck[]
f:deck.card.add["field" "out"]
f.script:"on change do sleep[1] out.text:typeof sleep end"
f.event["change"]
assert["in lilt, sleep[] is present but has no effect." "function" f.text]

deck:readdeck[]
deck.name:"synthetic event tests"
deck.author:"hamilton butters"
f:deck.card.add["field" "out"]
b:deck.card.add["button" "doit"]
b.script:"on custom a b do out.text:\"%s : %i, %s!\" format a,b,deck.author end"
b.event["custom" "str" 42]
assert["custom event injection" "str : 42, hamilton butters!" f.text]

deck.script:"on another do home.widgets.out.text:\"called by %s\" format me.name end"
b.event["another"]
assert["custom event inheritance" "called by doit" f.text]
deck.cards.home.event["another"]
assert["custom events from cards" "called by home" f.text]
deck.event["another"]
assert["custom events from decks" "called by synthetic event tests" f.text]

d:readdeck["examples/decks/enchilada.deck"]
c:d.cards["Sound Loops"]
b:c.widgets["button1"]
b.event["click"]

deck:readdeck[]
b:deck.card.add["button" "doit"]
b.script:"on custom x do 2+3*x end"
r:b.event["custom" 100]
assert["custom event rvalue" 302 r]

#######################################
#
#  Copying and Pasting
#
#######################################

deck:readdeck[]
home:deck.card
f:home.add["field" "thing"]
f.text:"Some Nice Text"

# note: the clipboard format is intended to be opaque,
# so tests should avoid inspecting or displaying it in any way.
copied:deck.copy[home]
v:deck.paste[copied]
assert["copy card: return value" "card"           (typeof v)]
assert["copy card: added card"   ("home","card1") (keys deck.cards)]
assert["copy card: made widgets" (list "thing")   (keys v.widgets)]
assert["copy card: made values"  "Some Nice Text" (v.widgets.thing.text)]

copied:v.copy[v.widgets.thing]
v.widgets.thing.text:"another"
vv:v.paste[copied]
assert["copy widgets: return value" "field"                      (typeof first vv)]
assert["copy widgets: added widget" ("thing","field1")           (keys v.widgets)]
assert["copy widgets: added value"  "Some Nice Text"             vv[0].text]
assert["copy widgets: no sharing"   ("another","Some Nice Text") (v.widgets.thing.text, v.widgets.field1.text)]

deck:readdeck[]
def:deck.add["contraption" "moveable"]
def.description:"A Moveable Feast"
def.add["button" "clicky"]
m:deck.card.add["contraption" "moveable" "instance"]
target:readdeck[]
copied:deck.card.copy[m]
target.card.paste[copied]
assert["copy contraption: instance" (list "instance") (keys target.card.widgets)]
assert["copy contraption: def"      (list "moveable") (keys target.contraptions)]
assert["copy contraption: def wids" (list "clicky"  ) (keys target.contraptions.moveable.widgets)]
target:readdeck[]
copied:deck.copy[deck.cards.home]
c:target.paste[copied]
assert["copy contraption card: instance" (list "instance") (keys c.widgets)]
assert["copy contraption card: def"      (list "moveable") (keys target.contraptions)]
assert["copy contraption card: def wids" (list "clicky"  ) (keys target.contraptions.moveable.widgets)]

deck:readdeck[]
f1:deck.add["font" 7,7 "alpha"] f1["A"]:deck.fonts.mono.A
f2:deck.add["font" 8,8 "beta" ] f2["A"]:deck.fonts.mono.B
f3:deck.add["font" 9,9 "gamma"] f3["A"]:deck.fonts.mono.C
b:deck.cards.home.add["button"] b.text:"clicky" b.font:f1
f:deck.cards.home.add["field" ] f.value:(rtext.make["plain"],rtext.make[" bold" "beta"])
def:deck.add["contraption" "fontie"]
b2:def.add["button" "also clicky"] b2.font:f3
s:deck.add["card" "second"]
m:s.add["contraption" "fontie" "instance"]
copied:deck.cards.home.copy[b,f]
target:readdeck[]
target.cards.home.paste[copied]
assert["copy widgets: fonts" ("body","menu","mono","alpha","beta") (keys target.fonts)]
copied:deck.copy[s]
target.paste[copied]
assert["copy card: fonts"    ("body","menu","mono","alpha","beta","gamma") (keys target.fonts)]
assert["copied font integrity" deck.fonts.beta .A.encoded target.fonts.beta .A.encoded]
assert["copied font integrity" deck.fonts.gamma.A.encoded target.fonts.gamma.A.encoded]

#######################################
#
#  Modules
#
#######################################

deck:readdeck[]
m:deck.add["module" "foof"]
assert["new module" ("module") (typeof m)]

mdef.description: m.description
mdef.script:      m.script
mdef.value:       m.value
mdef.error:       m.error
assert["module default fields" ("%j" parse "{'description':'','script':'','value':{},'error':''}") mdef]

m.script:"while 1 \"this is bad\" end"
assert["module script timeout: script" ("while 1 \"this is bad\" end")   m.script]
assert["module script timeout: value"  (() dict ())                      m.value ]
assert["module script timeout: error"  ("initialization took too long.") m.error ]

m.script:"(\"a\",\"b\")dict 22,33"
assert["module trivial script" (("a","b") dict 22,33) m.value]

m.description:"a trivial module"
m.name:"trivial"
writedeck["temp.deck" deck]
assert_file["serialize a trivial module" "tests/dom/module.deck" "temp.deck"]

ld:readdeck["tests/dom/logger.deck"]
assert["module data store" "keystore" (typeof ld.modules.logger.data)]
assert["module data, external" 1.01              ld.modules.logger.data.version]
assert["module data, keys"     ("version","log") ld.modules.logger.data.keys   ]
ld.modules.logger.data.version:0
assert["module data, delete zero"   (list "log") ld.modules.logger.data.keys   ]
ld.card.widgets.push.event["click"]
assert["module logger demo"
	insert time message with
		0 "zeroth"
		1 "first"
		2 "second"
		3 "third"
	end
	ld.card.widgets.pull.value
]
writedeck["temp.deck" ld]
assert_file["serialize a module with data" "tests/dom/logger2.deck" "temp.deck"]

deck:readdeck[]
m2:deck.add[m "namedcopy"]
assert["module copy with name" (().namedcopy:m2) (deck.modules)]

#######################################
#
#  Contraptions
#
#######################################

deck:readdeck[]

def:deck.add["contraption" "spinner"]
defaults:def @ "type","description","script","size"
assert["prototype default attributes" ("prototype","","",(list 100,100)) defaults]
assert["deck contraptions"        "dict"                  (typeof deck.contraptions)]
assert["deck contraption content" ("prototype","spinner") (typeof deck.contraptions.spinner),(keys deck.contraptions)]

def.description:"unbounded numeric picker"
def.size:150,50
def.attributes:insert name label type with
	"value" "Value" "number"
	"step"  "Step"  "number"
end
def.script:"
on set_value x do value.text:0+x end
on get_value   do 0+value.text   end
on set_step  x do step.text:0+x  end
on get_step    do 0+step.text    end"
def.template:"on change do\n \nend"
down:def.add["button" "down"]
down.text:"<"
down.script:"on click do
  value.text:value.text-step.text
end"
up:def.add["button" "up"]
up.text:">"
up.script:"on click do
  value.text:value.text+step.text
end"
value:def.add["field" "value"]
value.value:0
value.locked:1
step:def.add["field" "step"]
step.value:1
step.show:"none"

a:deck.card.add["contraption" "spinner" "a"]
b:deck.card.add[a "b"]
c:deck.card.add["contraption" "bogus" "ishouldnotexist"]
assert["contraption add bogus type" 0 c]
defaults:b @ "type","name","index","locked"
assert["contraption default attributes" ("contraption","b",1,0) defaults]
assert["contraption def" def b.def]
b.value:42
assert["contraption custom attrs get/set" (42,1) (b.value,b.step)]

writedeck["temp.deck" deck]
assert_file["write a deck with contraptions/prototypes." "tests/dom/contraptions.deck" "temp.deck"]
deck.remove[def]
assert["contraption deletion" 0 (count deck.contraptions)]
assert["contraption deletion scrubs instances" () (keys deck.card.widgets)]

deck:readdeck["tests/dom/contraptions.deck"]
def:deck.contraptions.spinner
assert["read contraption def" ("prototype","spinner",150,50) (def.type,def.name,def.size)]
assert["read contraption instances" ("a","b","contraption","contraption") ((keys deck.card.widgets),(deck.card.widgets..type))]
assert["read contraption base attr"      1 deck.card.widgets.a.step ]
assert["read contraption instance attr" 42 deck.card.widgets.b.value]

def.widgets.step.text:"15"
def.widgets.up.event["click"]
def.widgets.up.event["click"]
assert["events to a prototype" "30" def.widgets.value.text]
assert["proto update instances preserve local state"        42 deck.card.widgets.b.value]
deck.card.widgets.a.pos:35,37
def.update[]
assert["proto update instances preserve instance state" (35,37) deck.card.widgets.a.pos ]
assert["proto update instances preserve name"               "a" deck.card.widgets.a.name]

def.script:"won't parse"
assert["read contraption instance attr with broken script" 0 deck.card.widgets.b.value]
def.script:"on get_value do 34567 end"
assert["read contraption instance attr with fixed script" 34567 deck.card.widgets.b.value]

deck:readdeck[]
def:deck.add["contraption" "recurser"]
def.script:"on set_rec x do x.rec:x end"
con:deck.card.add["contraption" "recurser"]
assert["recursive custom attrs are automatically halted" con con.rec:con]

deck:readdeck[]
def:deck.add["contraption" "hardfield"]
fix:def.add["field" "fixed"]
fix.text:"Hard Label"
def.script:"on get_lab do fixed.text end   on set_lab x do fixed.text:x end"
inst:deck.card.add["contraption" "hardfield"]
assert["contraption value inheritance before" "Hard Label" inst.lab]
fix.text:"Another Label"
assert["contraption value inheritance after" "Another Label" inst.lab]
inst.lab:"Override Label"
assert["contraption value override" "Override Label" inst.lab]
fix.text:"Cannot Override"
assert["contraption value non-overridden" "Override Label" inst.lab]

deck:readdeck[]
def:deck.add["contraption" "sizey"]
def.size:12,34
con:deck.card.add["contraption" "sizey"]
assert["contraption inherit size" (12,34) con.size]
con.size:45,67
assert["contraption non-resizable" (12,34) con.size]
def.resizable:1
con.size:32,48
assert["contraption is resizable" (32,48) con.size]
def.resizable:0
assert["contraption size snapback" (12,34) con.size]

deck:readdeck[]
def:deck.add["contraption" "dispatcher"]
def.script:"on get_prop1 do 100+me.event[\"test\"] end on get_prop2 do 200+card.event[\"test\"] end"
con:deck.card.add["contraption" "dispatcher"]
con.script:"on test do 2+3 end"
assert["contraption attribute from event"   105 con.prop1]
assert["contraption attribute from event 2" 205 con.prop2]
def.script:"on get_d1 do (deck,patterns) end"
assert["contraption prop: access globals" (deck,deck.patterns) con.d1]

deck:readdeck[]
def:deck.add["contraption" "exposer"]
f:def.add["field" "w1"]
b:def.add["button" "w2"]
b.script:"
on thing1 do w1 end
on thing2 do w3 end
on thing4 do card.event[\"thing3\"] end
on thing5 do card.event[\"thing6\"] end
on thing7 do card end"
def.script:"on get_w do w2 end"
s:deck.card.add["slider" "w3"]
e:deck.card.add["contraption" "exposer"]
e.script:"
on thing3 do w3 end
on thing6 do card end"
assert["prototype member event can access other inner widgets"                                  f         b.event["thing1"]]
assert["contraption can expose member widgets"                                                  "button"  e.w.type]
assert["contraption exposed member event can access other inner widgets"                        "field"   e.w.event["thing1"].type]
assert["contraption exposed member event CANNOT access widgets on the container card"           0         e.w.event["thing2"]]
assert["contraption instance event handlers CAN access widgets on the container card"           s         e.event["thing3"]]
assert["contraption instances CAN fire events at the container card"                            s         e.w.event["thing4"]]
assert["prototype scripts observe 'card' as the prototype"                                      def       b.event["thing7"]]
assert["contraption scripts observe 'card' as the contraption instance"                         e         e.w.event["thing7"]]
assert["contraption instance event handlers observe 'card' as the container card via outside"   deck.card e.event["thing6"]]
assert["contraption instance event handlers observe 'card' as the container card via inside"    deck.card e.w.event["thing5"]]

#######################################
#
#  Lilt features
#
#######################################

if !sys.platform~"web"
	alpha:999
	i:import["tests/dom/import.lil"]
	assert["import keys" ("triple","alpha","beta") (keys i)]
	assert["import apply" ("A","A","A") i.triple["A"]]
	assert["import isolated" 999 alpha]
	assert["import nonexistent file" 0 import["does_not_exist.lil"]]
end

#######################################
#
#  Brushes
#
#######################################

deck:readdeck[]
c:deck.card.add["canvas"]
c.size:15,11
deck.card.script:"
	on install do
		brush[\"star\" image[\"%%IMG0AAkACQgAHAAcAP+AfwA+AH8AdwDjgA==\"]]
	end
"
deck.card.event["install"]
c.brush:"star"
assert["custom brush index by name" 24 c.brush]
c.line[(5,5) (9,5)]
assert["custom brush line: star" "%%IMG0AA8ACwAAB8AP4A/gf/w/+B/wP/g/+H/8AAA=" c.copy[].encoded]

deck.card.script:"
	on install do
		brush[\"diag\" image[\"%%IMG0AAIAAkCA\"]]
	end
"
deck.card.event["install"]
c.clear[]
c.brush:"diag"
c.box[1,1 13,9]
assert["custom brush box: diag" "%%IMG0AA8AC3/8//zADMAMwAzADMAMwAz//P/4AAA=" c.copy[].encoded]

deck.card.script:"
	on install do
		i:0
		brush[on dotted do
			i:!i
			if i image[1,1].map[0 dict 1] end
		end]
	end
"
deck.card.event["install"]
c.clear[]
c.brush:"dotted"
c.line[1,1 13,9]
assert["custom brush line: dotted" "%%IMG0AA8ACwAAQAAQAAAABAABAABAAAAAEAAEAAA=" c.copy[].encoded]

deck.card.script:"on install do brush[] end"
assert["custom brush enumeration" ("star","diag","dotted") (keys deck.card.event["install"])]

#######################################
#
#  Wrap Up
#
#######################################

if 0~assert
	print["internal error; environment corruption!"]
else
	print["all dom tests passed."]
end
