# Command-line minesweeper in Lil

if !5~count args
 print["Usage: lilt mines.lil width height mines_count"]
 exit[0]
end

# game state:
local mines :0  # {0,1} image; is there a mine here?
local seen  :0  # {0,1} image; has this tile been revealed?
local around:0  # [0-9] image; adjacent mine count

on setup size mine_count do
 mines:image[size]
 seen :image[size]
 # select mine positions without replacement:
 each pos in random[(size[0] cross size[1]) (-mine_count)]
  mines[pos]:1
 end
 # compute adjacent mine counts for all tiles in parallel:
 horiz:mines.copy[]
  .merge["+" mines.copy[].translate[-1,0]]
  .merge["+" mines.copy[].translate[ 1,0]]
 around:horiz.copy[]
  .merge["+" horiz.copy[].translate[0,-1]]
  .merge["+" horiz.copy[].translate[0, 1]]
end

on reveal pos do
 # depth-first traversal of empty tiles:
 on revealrec here do
  if !seen[here]
   seen[here]:1
   if (!around[here])&(min -1<here)&(min here<mines.size)
    revealrec @ flip here+flip (list 0,0) drop (3 cross 3)-1
   end
  end
 end
 revealrec[pos]
 # the game is over if we picked a mined tile
 # OR we've revealed everything except the mines:
 if     mines[pos]                "lose"
 elseif mines.pixels~!seen.pixels "win"
 else                             "play"
 end
end

on display do
 # include legends on the top and left,
 # to aid in arriving at coordinates:
 print["\n   %s" floor .1*range mines.size[0]]
 print["   %s\n" 10%      range mines.size[0]]
 each row in range mines.size[1]
  print[("%02i " format row),each col in range mines.size[0]
   pos:col,row
   if     !seen[pos] "#"
   elseif mines[pos] "*"
   else "_" unless around[pos]
   end
  end]
 end
 print[""]
end

# lilt uses a hardcoded initial seed for reproducibility,
# which is undesirable for an entertaining game:
sys.seed:sys.ms
setup[0+args@2,3 0+args[4]]

while 1
 display[]
 r:reveal["%i,%i" parse input["x,y > "]]
 if r in ("win","lose")
  seen.map[() 1]
  display[]
  print["You %s!" r]
  exit[0]
 end
end
